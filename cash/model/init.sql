-- MySQL Script generated by MySQL Workbench
-- mar 16 nov 2021, 14:10:42
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema belexo
-- -----------------------------------------------------
-- DROP SCHEMA IF EXISTS `belexo` ;

-- -----------------------------------------------------
-- Schema belexo
-- -----------------------------------------------------
-- CREATE SCHEMA IF NOT EXISTS `belexo` ;

-- USE `belexo` ;

-- -----------------------------------------------------
-- Table `fsnodes`
-- This table contains the "file system nodes": files and directories
-- -----------------------------------------------------
DROP TABLE IF EXISTS `fsnodes` ;

CREATE TABLE IF NOT EXISTS `fsnodes` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(1024) NOT NULL,
  `type` VARCHAR(1) NOT NULL, -- 'F' for file, 'D' for directory
  `created` DATETIME NULL,
  `modified` DATETIME NULL,
  `father` INT NULL,
  PRIMARY KEY (`id`),
  UNIQUE INDEX `id_UNIQUE` (`id` ASC) VISIBLE,
  INDEX `father_idx` (`father` ASC) VISIBLE,
  INDEX `fs_name_idx` (`name`(256) ASC) VISIBLE,
  INDEX `fs_father_name_idx` (`father` ASC, `name`(256) ASC) VISIBLE,
  CONSTRAINT `father_fk`
    FOREIGN KEY (`father`)
    REFERENCES `fsnodes` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION)
ENGINE = InnoDB
DEFAULT CHARACTER SET = UTF8MB4
COLLATE = UTF8MB4_unicode_ci;


-- -----------------------------------------------------
-- Table `str_fs_props`
-- Properties of an fsnode. These could be metadata (meta=1)
-- or whatever we might need on the server side.
-- -----------------------------------------------------
DROP TABLE IF EXISTS `str_fs_props` ;

CREATE TABLE IF NOT EXISTS `str_fs_props` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(256) NOT NULL,
  `value` JSON NULL,
  `value_str` TEXT GENERATED ALWAYS as ( value ->> "$" ) STORED NULL,
  `value_type` VARCHAR(32) GENERATED ALWAYS as (JSON_TYPE(value)) NULL,
  `node` INT NOT NULL,
  `meta` TINYINT(1) DEFAULT 0,
  PRIMARY KEY (`id`),
  INDEX `sn_node_idx` (`node` ASC) VISIBLE,
  INDEX `sn_name_idx` (`name` ASC) VISIBLE,
  INDEX `sn_value_idx` (`value_str`(256) ASC) VISIBLE,
  INDEX `sn_name_node_idx` (`name` ASC, `node` ASC) VISIBLE,
  INDEX `sn_value_node_idx` (`value_str`(256) ASC, `node` ASC) VISIBLE,
  FULLTEXT `sn_value_ftx` (`value_str`),
  CONSTRAINT `str_node_fk`
    FOREIGN KEY (`node`)
    REFERENCES `fsnodes` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION)
ENGINE = InnoDB
DEFAULT CHARACTER SET = UTF8MB4
COLLATE = UTF8MB4_unicode_ci;


-- -----------------------------------------------------
-- Table `blob_fs_props`
-- 'blob' properties -- namely, the content data of the file,
-- along with its mime type.
-- -----------------------------------------------------
DROP TABLE IF EXISTS `blob_fs_props` ;

CREATE TABLE IF NOT EXISTS `blob_fs_props` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(256) NOT NULL,
  `value` MEDIUMBLOB NULL,
  `content_type` VARCHAR(256),
  `node` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `bn_node_idx` (`node` ASC) VISIBLE,
  INDEX `bn_name_idx` (`name` ASC) VISIBLE,
  INDEX `bn_name_node_idx` (`name` ASC, `node` ASC) VISIBLE,
  CONSTRAINT `bn_node_fk`
    FOREIGN KEY (`node`)
    REFERENCES `fsnodes` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION)
ENGINE = InnoDB
DEFAULT CHARACTER SET = UTF8MB4
COLLATE = UTF8MB4_unicode_ci;


-- -----------------------------------------------------
-- Table `unstructured`
-- This table holds the 'plain text' extracted from the
-- file. The uses for this table are:
-- 1. a means to perform fast searches on a fulltext index;
-- 2. a reference for the spans relative to an annotation
-- NOTE: the last bit might be problematic. Spans are more
-- likely to be produced on the frontend side. We should
-- probably think of returning the text ourselves to the
-- frontend.
-- -----------------------------------------------------
DROP TABLE IF EXISTS `unstructured` ;

CREATE TABLE IF NOT EXISTS `unstructured` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `text` MEDIUMTEXT NULL,
  `type` VARCHAR(256) NULL, -- interpretative, ...
  `node` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `u_node_idx` (`node` ASC) VISIBLE,
  FULLTEXT `un_text_ftx` (`text`),  
  CONSTRAINT `u_node_fk`
    FOREIGN KEY (`node`)
    REFERENCES `fsnodes` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION)
ENGINE = InnoDB
DEFAULT CHARACTER SET = UTF8MB4
COLLATE = UTF8MB4_unicode_ci;

-- -----------------------------------------------------
-- Table `tokens`
-- Tokens are a special kind of annotation. Not clear
-- whether they should be so special that they need
-- to be on a dedicated table. There might be issues with the
-- span definition (see 'unstructured' table). We need to
-- decide whether to link the token to a specific type of
-- extraction (a specific row in the 'unstructured' text)
-- -----------------------------------------------------
DROP TABLE IF EXISTS `tokens` ;

CREATE TABLE IF NOT EXISTS `tokens` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `text` VARCHAR(1024) NULL,
  `position` INT NOT NULL,
  `begin` INT NOT NULL,
  `end` INT NOT NULL,
  `xmlid` varchar(256) NULL,
  `node` INT NOT NULL,
  `srctxt` INT NULL, -- the actual text (unstructured) it refers to
  -- This makes the reference to 'node' redundant and not normal,
  -- but it saves us from an extra join at query time
  `imported` BOOLEAN NOT NULL DEFAULT 0, -- autom. generated?  
  PRIMARY KEY (`id`),
  INDEX `tok_text_idx` (`text`(256) ASC) VISIBLE,
  INDEX `tok_xmlid_idx` (`xmlid`(256) ASC) VISIBLE,
  INDEX `tok_node_idx` (`node` ASC) VISIBLE,
  INDEX `tok_srctxt_idx` (`srctxt` ASC) VISIBLE,
  INDEX `tok_text_node_idx` (`text`(256) ASC, `node` ASC) VISIBLE,
  CONSTRAINT `tok_node_fk`
    FOREIGN KEY (`node`)
    REFERENCES `fsnodes` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION,
  CONSTRAINT `tok_srctxt_fk`
    FOREIGN KEY (`srctxt`)
    REFERENCES `unstructured` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION    )
ENGINE = InnoDB
DEFAULT CHARACTER SET = UTF8MB4
COLLATE = UTF8MB4_unicode_ci;

-- -----------------------------------------------------
-- Table `annotations`
-- Annotations are imported from a file and/or added via API
-- Spans are in a separate table referring to this one.
-- annref and tokref are references to tokens and annotations
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `annotations` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `layer` VARCHAR(1024) NOT NULL,
  `value` VARCHAR(1024) NULL,
  `author` VARCHAR(255) NULL,
  `note` TEXT NULL,
  `valid` TINYINT(1) NOT NULL DEFAULT 1, -- deleted annotations are 'invalid'
  `created` DATETIME NOT NULL,
  `confidence` FLOAT NOT NULL DEFAULT 1,
  -- `begin` INT NOT NULL, -- spans are in a separate table,
  -- `end` INT NOT NULL,   -- but they could be added here for speed
  `externalRef` VARCHAR(1024) NULL,
  `node` INT NOT NULL,
  `imported` BOOLEAN NOT NULL DEFAULT 0, -- whether this is autom. generated
  PRIMARY KEY (`id`),
  INDEX `ann_value_idx` (`value`(256) ASC) VISIBLE,
  INDEX `ann_node_idx` (`node` ASC) VISIBLE,
  INDEX `ann_layer_node_idx` (`layer`(256) ASC, `node` ASC) VISIBLE,
  INDEX `ann_value_node_idx` (`value`(256) ASC, `node` ASC) VISIBLE,
  INDEX `ann_value_layer_node_idx` (`value`(256) ASC, `layer`(256) ASC, `node` ASC) VISIBLE,
  CONSTRAINT `ann_node_fk`
    FOREIGN KEY (`node`)
    REFERENCES `fsnodes` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION)
ENGINE = InnoDB
DEFAULT CHARACTER SET = UTF8MB4
COLLATE = UTF8MB4_unicode_ci;

-- -----------------------------------------------------
-- Table `str_ann_props`
-- Properties of annotations.
-- Skip the first level and just go with a JSON column
-- in an annotation?
-- -----------------------------------------------------
DROP TABLE IF EXISTS `str_ann_props` ;

CREATE TABLE IF NOT EXISTS `str_ann_props` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(256) NOT NULL,
  `value` JSON NULL,
  `value_str` TEXT GENERATED ALWAYS as ( value ->> "$" ) STORED NULL,
  `value_type` VARCHAR(32) GENERATED ALWAYS as (JSON_TYPE(value)) NULL,
  `ann` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `sa_ann_idx` (`ann` ASC) VISIBLE,
  INDEX `sa_name_idx` (`name` ASC) VISIBLE,
  INDEX `sa_value_idx` (`value_str`(256) ASC) VISIBLE,
  INDEX `sa_name_ann_idx` (`name` ASC, `ann` ASC) VISIBLE,
  INDEX `sa_value_ann_idx` (`value_str`(256) ASC, `ann` ASC) VISIBLE,
  FULLTEXT `sa_value_ftx` (`value_str`),
  CONSTRAINT `sa_ann_fk`
    FOREIGN KEY (`ann`)
    REFERENCES `annotations` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION)
ENGINE = InnoDB
DEFAULT CHARACTER SET = UTF8MB4
COLLATE = UTF8MB4_unicode_ci;

-- -----------------------------------------------------
-- Table `lnk_ann_props`
-- Link between an annotation and another
-- This is a special property type representing the
-- link between two annotations. What we're really
-- missing here is a link between annotations and a
-- TOKEN.
-- -----------------------------------------------------
DROP TABLE IF EXISTS `lnk_ann_props` ;

CREATE TABLE IF NOT EXISTS `lnk_ann_props` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `sourceann` INT NOT NULL,
  `targetann` INT NULL,
  `targettok` INT NULL,
  PRIMARY KEY (`id`),
  INDEX `sa_srcann_idx` (`sourceann` ASC) VISIBLE,
  INDEX `sa_targetann_idx` (`targetann` ASC) VISIBLE,
  CONSTRAINT `sa_srcann_fk`
    FOREIGN KEY (`sourceann`)
    REFERENCES `annotations` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION,
  CONSTRAINT `sa_trgann_fk`
    FOREIGN KEY (`targetann`)
    REFERENCES `annotations` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION,
  CONSTRAINT `sa_trgtok_fk`
    FOREIGN KEY (`targettok`)
    REFERENCES `tokens` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION
    )
ENGINE = InnoDB
DEFAULT CHARACTER SET = UTF8MB4
COLLATE = UTF8MB4_unicode_ci;

-- -----------------------------------------------------
-- Table `ann_spans`
-- This is the list of spans it featured by an annotation.
-- There could be multiple spans for an annotation.
-- -----------------------------------------------------
DROP TABLE IF EXISTS `ann_spans` ;

CREATE TABLE IF NOT EXISTS `ann_spans` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `ann` INT NOT NULL,
  `begin` INT NOT NULL,
  `end` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `as_ann_idx` (`ann` ASC) VISIBLE,
  INDEX `as_ann_begin_end_idx` (`ann` ASC, `begin` ASC, `end` ASC) VISIBLE,
  CONSTRAINT `as_ann_fk`
    FOREIGN KEY (`ann`)
    REFERENCES `annotations` (`id`)
    ON DELETE CASCADE
    ON UPDATE NO ACTION
    )
ENGINE = InnoDB
DEFAULT CHARACTER SET = UTF8MB4
COLLATE = UTF8MB4_unicode_ci;


SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;

-- -----------------------------------------------------
-- Function `SpanMatch`
-- The SpanMatch function tells whether an annotation
-- features a span (of its potentially multiple)
-- matching the area.
-- -----------------------------------------------------
DELIMITER $$

DROP FUNCTION IF EXISTS `SpanMatch`;

CREATE FUNCTION `SpanMatch`(
       `annotation` INT,
       `lft` INT,
       `rgt` INT
) RETURNS INT
DETERMINISTIC
BEGIN
	DECLARE ret INT;
	SET ret = 0;
	SELECT count(a.id) INTO ret FROM `ann_spans`as a WHERE a.ann=annotation AND a.`begin`<=lft AND a.`end`>=rgt LIMIT 1;

	RETURN ret;
END$$
DELIMITER ;

-- -----------------------------------------------------
-- Function `TokenMatch`
-- The SpanMatch function tells whether an annotation
-- features a span (of its potentially multiple)
-- matching a token's.
-- -----------------------------------------------------
DELIMITER $$

DROP FUNCTION IF EXISTS `TokenMatch`;

CREATE FUNCTION `TokenMatch`(
       `annotation` INT,
       `token` INT
) RETURNS INT
DETERMINISTIC
BEGIN
	DECLARE ret INT;
	SET ret = 0;
	SELECT count(a.id) INTO ret FROM `ann_spans`as a, `tokens` as t, `annotations` as ann WHERE t.id=token AND ann.id=annotation and t.node=ann.node AND a.ann=annotation AND a.`begin`<=t.`begin` AND a.`end`>=t.`end` LIMIT 1;

	RETURN ret;
END$$
DELIMITER ;


SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;


